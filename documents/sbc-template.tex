\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
     
\sloppy

\title{Workflow de desenvolvimento em C/C++ baseado em TDD. \\Pre-tested commits}

\author{Helton Luiz Marques\inst{1}} 

\address{Univali -- Universidade do Vale do Itajaí\\
		Pós--Graduação em Qualidade e Engenharia de Software\\
		Florianópolis -- SC -- Brasil
		\email{helton.marx@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
	A proposta deste trabalho é apresentar o conceito de Test Driven Development,  
	mostrar os benefícios que esta abordagem traz para os desenvolvedores, e 
	também apresentar a revisão de código para análise e busca de falhas no 
	código fonte, alterações na arquitetura do sistema, reimplementação de 
	funcionalidades já existentes, duplicidade de códigos e melhorias de 
	estética e padronização
	São apresentados os benefícios da utilização dessas metodologias e 
	por fim um workflow de desenvolvimento em C/C++ baseado em TDD.
\end{resumo}


\section{Introdução}

Com a popularização dos métodos ágeis difundiu--se e muito o desenvolvimento
orientado a testes (\textit{Test Driven Development}), onde há uma busca 
constante em eliminar falhas de programação durante a codificação, com foco 
principalmente em design, pois produzir um código testável implica em baixo 
acoplamento, além do acréscimo de qualidade sobre produto de software.\\
Além dos testes unitários, há também a revisão de código, que integrado a um 
sistema testes automatizados e um sistema de controle de versão obtem-se uma 
metodologia de trabalho eficaz e que traz velocidade e segurança no 
desenvolvimento de sistemas, principalmente em C/C++ em que há uma gama enorme 
de plataformas e arquiteturas para esta linguagem.\\
Este artigo apresentará uma proposta de workflow para desenvolvimento em C/C++ 
baseado em TDD, utilizando \textit{pre-tested commits}, sendo possível 
expandí-lo a outras linguagens de programação.

\newpage

\section {Fundamentação Teórica} \label{sec:theoreticalFoundation}

\textit{Test Driven Development} (TDD) é uma abordagem iterativa para 
desenvolvimento de software baseada em testes automatizados. 
A idéia é aplicar pequenos ciclos de teste-codificação-refatoração, 
também conhecido como \textit{red-green-refactor} que consiste em criar um 
teste unitário que faça falhar o código desenvolvido (\textit{Red}), 
alterar o código para que o teste passe da forma mais simples (\textit{Green}) 
e refatorar o código com o objetivo de melhorar a sua estrutura e design 
(\textit{Refactor}).
Este ciclo deve ser repetido em pequenos incrementos, até que a funcionalidade 
esteja pronta.\\Assim em cada iteração, a complexidade vai aumentado aos poucos, 
porém com a certeza que há corretude em cada implementação.\\
Cada passo traz um benefício. Escrever o teste antes, prática conhecida 
como \textit{Test First}, obrigatoriamente força com que o código produzido 
seja testável por construção, e código testável implica código com baixo 
acoplamento, aspecto extremamente importante no design de software.\\ 
Ao escrever testes previamente, faz com que o desenvolvedor pense 
antecipadamente no comportamento que a aplicação deve ter, antes mesmo de 
escrever algum código. Desde a implementação, o projeto terá um nível de 
qualidade mais apurado, já que esta técnica força pensar em problemas e 
suas soluções antes de qualquer código existir.\\
Além disso, obtem--se o \textit{feedback} imediato a cada refatoração, 
e também suprime o \textit{over--engineering}, ou seja, implementar mais do que
o estritamente necessário.\\O feedback acontece a cada ciclo, dando uma margem 
de segurança ao desenvolvedor, de o que está sendo implementado além de correto 
é necessário.\\TDD pode ser aplicado tanto para pequenas partes que compõem um 
sistema (Teste Unitários) quanto para componentes (Testes de Integração), e 
traz benefícios tanto em design quanto em performance, pois depende da 
Arquitetura de Teste aplicada para garantir uma boa cobertura de testes, tem-se 
um tempo relativamente menor na resolução de falhas do sistema total.\\
Além de diminuir o custo na fase de manutenção do sistema, oferece também uma 
margem de segurança maior aos desenvolvedores.\\Os testes automatizados também 
podem funcionar como uma forma de documentação, pois estão descrevendo em 
partes o comportamento do sistema, suas interfaces, métodos e arquitetura.\\
TDD é entendido como um dos princípios da Extreme Programming (XP).\\
Os principais benefícios do TDD são:
\begin{itemize}
	\item
		\textbf{Diminuição de falhas:} 
		Erros de lógica e também falhas de design podem 
		ser encontrados rapidamente durante o TDD, ocorrendo previamente a 
		prevenção de defeitos.
	\item
		\textbf{Menor tempo de debug:} 
		Com um menor número de falhas, obtêm-se um menor tempo de debug.
	\item
		\textbf{Documentação não mente:} 
		Com testes bem estruturados, é possível analisar a qualidade da 
		documentação. Testes bem estruturados trazem uma forma mais vísivel
		através de um exemplo funcional, suprindo uma documentação excassa.
	\item
		\textbf{Paz de espírito:} 
		Um código exaustivamente testado com um conjunto abrangente 
		de testes de unitários traz estabilidade e confiança aos desenvolvedores, 
		trazendo conforto e fins de semana despreocupados.
	\item
		\textbf{Aperfeiçoamento do design:} 
		Um bom design é um design testável. 
		Funções muito grandes, forte acoplamento e condicionais complexas 
		tornam o código mais complexo e menos testável. Os desenvolvedores 
		percebem previamente uma falha de design caso os testes não possam ser 
		implementados.
	\item
		\textbf{Monitorar o progresso:}
		Os testes trazem exatamente um retrato do que está funcionando e uma 
		porcentagem real do trabalho realizado.
	\item
		\textbf{Feedback imediato:}
		O TDD traz imediatamente uma gratificação aos desenvolvedores. 
		A cada codificação testada, há uma garantia de que o software 
		implementando está funcionando
\end{itemize}

\subsection{Test-First e Test-Last}	\label{sec:testFirstLast}

Há duas abordagens em relação aos teste unitários, 
que são o \textit{Test-First} que força que o código de teste seja produzido 
antes da implementação do algoritmo, e o \textit{Test-Last} que ao inverso, 
é a elaboração do teste unitário após a conclusão do algoritmo a ser testado.\\
\cite{erdogmus:05}, resolveram investigar, por meio de um experimento 
as diferenças entre as abordagens \textit{Test-First} e \textit{Test-Last}. 
O experimento consiste em dois grupos em meio acadêmico, cada qual usando umas 
das abordagens. As conclusões foram as seguintes: 
o grupo \textit{Test-First} acabou escrevendo 52\% mais testes do que o grupo 
\textit{Test-Last}, algo bastante significativo. 
Em termos de qualidade externa, pelo estudo, não houve diferença entre os dois 
métodos. Houveram sim, evidências de que a qualidade externa estaria mais 
relacionada ao números de testes escritos do que quando estes 
são escritos previamente.\\ 
Segundo os autores, apesar do método Test-First por si só não aumentar a 
qualidade, este pareceu ter um efeito positivo sobre a produtividade dos 
desenvolvedores, possívelmente por causa dos seguintes fatores:

\begin{itemize}
	\item
		\textbf{Melhor compreensão do problema:}
		Especificar o teste antes força o desenvolvedor a refletir de maneira 
		mais profunda e completa sobre o problema a ser resolvido. 
		Criar cenários de testes antes ajuda a provar a robustez da solução 
		proposta.
	\item
		\textbf{Melhor foco na tarefa a ser feita:}
		Existe uma menor carga cognitiva sobre o desenvolvedor, 
		pois ele estará concentrado em resolver apenas uma pequena porção do 
		problema, somente o suficiente para atender o teste existente falhando.
	\item
		\textbf{Aprendizado mais rápido:}
		O desenvolvedor saberá mais rapidamente se a funcionalidade implementada
		está de acordo com o esperado. Além disso, existe um critério inequívoco 
		para saber quando o trecho de funcionalidade está realmente pronto.
	\item
		\textbf{Menos esforço de retrabalho:}
		Em uma abordagem \textit{Test-Last}, corre-se o risco de pouca 
		refatoração, desenvolvendo a funcionalidade por inteiro, incorrendo em 
		retrabalho à medida que os testes forem criados posteriormente e 
		apontarem outros problemas.
\end{itemize}

O estudo demonstra claramente uma qualidade maior ao utilizarmos 
\textit{Test-First}, porém deve-se levar em consideração diversos fatores ao 
selecionar um método, principalmente quando há uma equipe mais experiente que 
saiba gerar produtividade unindo os dois métodos. Além disso, o risco da 
abordagem \textit{Test-Last} está na perda do benefício da programação por 
interação, ou seja, evoluir o software a partir do ponto de vista de como se 
espera que seja usado, e também a ocorrência em demasia de 
\textit{over--engineering}, isto é, escrever código para coisas que talvez não 
sejam necessárias naquele momento. 

\subsection{Testes Automatizados}	\label{sec:automatedTests}

São uma ferramenta extremamente valiosa de feedback, 
ajudando a garantir tanto a qualidade externa (aquela perceptível pelo usuário), 
quanto à qualidade interna (aquela perceptível pelo desenvolvedor).\\
A facilidade de poder executar continuamente os testes permite a identificação 
imediata de alterações indesejáveis no sistema. Por essa razão, 
os testes existentes para um sistema também são conhecidos como 
Testes de Regressão, pois asseguram que um sistema não irá regredir do ponto 
atual em que se encontra. O acréscimo contínuo de funcionalidades pode ser 
realizado sem medo de quebrar algo já estabilizado.\\
Os testes também favorecem a prática saudável de refatoração, que consiste em 
aplicar pequenas transformações na estrutura interna do software, preservando 
o comportamento externo, com o objetivo de melhorar o código, tornando-o mais 
legível e mais aderente às manutenções pelas quais deverá passar. 
Entretanto é necessário a busca pelo equilíbrio da refatoração, que deve ser 
disciplinada para manter a qualidade do código escrito.\\
Deve-se observar que o Teste Unitário é a base para os Testes de Integração, 
pois trazem um feedback imediato, encorajando o desenvolvedor a executá-los 
mais frequentemente, até a execução de todos os testes do sistema em um 
servidor de integração contínua.\\      
É vital que existam testes automatizados que sejam fáceis e rápidos de 
serem executados, pois caso contrário, os testes serão executados poucas vezes 
e os bugs serão descobertos de forma tardia no ciclo de desenvolvimento.

\subsection{Revisão de código fonte}	\label{sec:codeRevision}

O melhor período para se encontrar falhas em código fontes é durante a 
codificação.\\
Conforme relatado em \cite{jones:07}, inspeções de código formais são cerca de 
duas vezes tão eficiente quanto qualquer forma conhecida de testes para 
encontrar profundamente falhas sutis de programação, e são o único método 
conhecido que tem uma média acima de 80 por cento na eficiência de remoção de 
defeitos.\\
Infelizmente, há dificuldades em convencer desenvolvedores e gestores sobre 
tais vantagens.Gestores preocupam-se sobre a demanta de tempo utilizada para 
esta atividade, que conflita com o cronograma do projeto, sem claro considerar
o ganho obtido pela busca não tardia de falhas de programação, por outro lado, 
desenvolvedores sentem-se desconfortáveis com revisões de código, 
principalmente por atingir seus egos e demonstrar suas falhas. 
Aliado a testes unitários consisos e a rigorosas sessões de revisão de código, 
é possível concluir uma tarefa livre de falhas antecipamente a inclusão dela no 
sistema através do controle de versão.\\
Há alguns métodos utilizados para revisão de código.
\begin{itemize}
	\item
		\textbf{Revisão Tardia:}
		É realizado um evento em que será realizado uma sessão de revisão de 
		código por todas as equipes da empresa, o que demonstra não ser a forma 
		mais eficaz de realizar as revisões de código, porque  
		grandes equipes de avaliação tendem a entrar em longas discussões e 
		uma revisão muito ampla não só pode ser desnecessário, 
		mas pode até ser prejudicial para o progresso do projeto.
	\item
		\textbf{Jogo Pick-up:}
		Assim que algum código é escrito, compilado, testado e pronto 
		para o \textit{commit}, o código é capturado para análise por outro 
		desenvolvedor. As revisão de \textit{pré--commit} são designados para 
		serem rápidos e sem extensas discussões, o que garante um código é 
		aceitável.Para eliminar quaisquer rotinas comportamentais ou vícios, o 
		ideal é que a revisão seja realizada por desenvolvedores distintos a 
		cada semana.
	\item
		\textbf{Programação em Par:}
		Utilizar a programação sempre em duplas, onde um desenvolvedor fica no 
		conduz a programação, utlizando o teclado e um outro desenvolvedor 
		senta-se ao lado e atua como navegador, indicando melhorias e falhas.
		De vez em quando, alternam-se os papéis.
		Com isso, há um aumento de atenção e crítica sobre o desenvolvimento 
		de uma funcionalidade.
		O ideal é integração entre desenvolvedores mais experientes, 
		com menos os experientes, para um aprendizado mútuo.
\end{itemize}

Outra técnica útil é utilizar um checklist para a revisão de código, por exemplo:
\begin{itemize}
	\item 
		É possível ler e compreender o código? 
	\item 
		Há alguma possível falha?
	\item 
		Será que o código tem qualquer efeito indesejável em outras partes 
		da aplicação? 
	\item 
		Existe alguma duplicação de código?
	\item 
		É possível aplicar melhorias ou refatoração para melhorar o código?
\end{itemize}
Além disso, é possível utilizar ferramentas de análise de código, como por 
exemplo, o \cite{website:gerrit}, que integradas ao sistema de 
controle de versão executam revisões em grupo do tipo
\textit{post--commit}, isto é, o código recém enviado ao repositório sofre uma 
análise de um grupo de desenvolvedores, que aprovam ou não o código, 
indicando melhorias e alterações.

\subsection{Pre-Tested Commits}	\label{sec:preTestedCommits}

A proposta do \textit{pre-tested commit}, é dedicar um 
\textit{repositório primário} ligado ao servidor de Integração Contínua para 
que execute os testes unitários e de integração, antes de ir para o 
repositório principal.\\
Isto é necessário porque normalmente desenvolvedores não executam testes após 
a conclusão de uma tarefa, enviando para o repositório uma possível falha.
Este tipo de ação é justificada para um sistema muito complexo, com 
\textit{n} testes de integração, e que demandam muito tempo, até horas para 
completar todo o processo de testes.\\
Obviamente. é mandatório que o desenvolvedor execute seus testes unitários, 
mas há também, uma possibilidade que seus testes não cubram uma falha gerada 
acidentalmente em outra parte do sistema. 
Portanto, para que não ocorra quebra do repositório principal o 
\textit{pre-tested commit} é utilizado.\\
A utilização dele está fortemente ligado ao sistema de controle de versão, 
como o \cite{website:teamcity} ou a um conjunto 
de ferramentas configuradas para tal função, como por exemplo a utilização do 
\cite{website:git}(SCV), 
\cite{website:jenkins}(Integração Contínua), 
\cite{website:gtest}(Testes unitários) e o 
\cite{website:gerrit}(Revisão de Código).\\

\newpage

\section{Workflow}	\label{sec:workflow}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1.0\textwidth]{../processos/workflow.png}
	\caption{Workflow}
	\label{fig:workflow}
\end{figure}

You think water moves fast? You should see ice. 
It moves like it has a mind. 
Like it knows it killed the world once and got a taste for murder. 
After the avalanche, it took us a week to climb out. 
Now, I don't know exactly when we turned on each other, 
but I know that seven of us survived the slide... and only five made it out. 
Now we took an oath, that I'm breaking now. 
We said we'd say it was the snow that killed the other two, 
but it wasn't. 
Nature is lethal but it doesn't hold a candle to man.
(Figure~\ref{fig:workflow}).

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1.0\textwidth]{../processos/TDD.png}
	\caption{Workflow TDD}
	\label{fig:TDD}
\end{figure}

The path of the righteous man is beset on all sides by the 
iniquities of the selfish and the tyranny of evil men. 
Blessed is he who, in the name of charity and good will, 
shepherds the weak through the valley of darkness, 
for he is truly his brother's keeper and the finder of lost children. 
And I will strike down upon thee with great vengeance and furious 
anger those who would attempt to poison and destroy My brothers. 
And you will know My name is the Lord when I lay My vengeance upon thee.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1.0\textwidth]{../processos/codeRevision.png}
	\caption{Workflow Revis\~ao de Codigo}
	\label{fig:codeRevision}
\end{figure}

My money's in that office, right? 
If she start giving me some bullshit about it ain't there, 
and we got to go someplace else and get it, 
I'm gonna shoot you in the head then and there. 
Then I'm gonna shoot that bitch in the kneecaps, 
find out where my goddamn money is. She gonna tell me too. 
Hey, look at me when I'm talking to you, motherfucker. 
You listen: we go in there, and that nigga Winston or 
anybody else is in there, you the first motherfucker to get shot. You understand?
	
\section{Avaliação}		\label{sec:evaluation}

Now that we know who you are, I know who I am. I'm not a mistake!
It all makes sense! In a comic, you know how you can tell who the arch-villain's going to be? 
He's the exact opposite of the hero.
And most times they're friends, like you and me! I should've known way back when... 
You know why, David? Because of the kids. 
They called me Mr Glass.

\section{Conclus\~ao}	\label{sec:conclusion}

Well, the way they make shows is, they make one show. 
That show's called a pilot. Then they show that show to the people who make shows, 
and on the strength of that one show they decide if they're going to make more shows. 
Some pilots get picked and become television programs. 
Some don't, become nothing. 
She starred in one of the ones that became nothing.

\newpage

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
